# TCP 控制传输协议 
---  

### 一 TCP传输的特点：   
1 TCP是面向连接的传输层协议。与UDP不同的是，TCP在发送数据的时候，需要进行连接，在TCP传输完数据后，必须要对连接进行释放  
2 TCP连接只能提供点对点的连接  
3 TCP提供可靠的交付服务。通过TCP传输的数据可以保证无差错、无丢失、不重复、按序到达  
4 TCP提供全双工通讯。在同一条TCP连接上的两个点可以互相传输数据  
5 TCP是面向字节流的传输，应用程序与TCP的交互式一次一个数据块，但是对于TCP来说，数据只是一连串无结构的字节流，TCP并不知道传输的字节流的含义。  
### 二 什么是可靠的传输？  
**1 简介：**  
我们知道，IP层只能提供最大努力的服务，所以，IP层的传输是不可靠的，所以TCP必须采用某种措施，才能让传输变得可靠。可靠传输有两个特点，分别是：  
（1）传输信道不产生差错  
（2）不管发送方传输数据的速度有多快，接收方都必须跟上发送方的节奏，及时处理传输过来的数据。  

**2 如何保证可靠传输？**  
*2.1 停止等待协议*  
发送方发送一段数据后，就停止传输数据，等待接收方接受完数据后，返回确认指令，然后发送方继续发送接下来的一段数据。这个时候，如果接收方检测发送方数据的时候出错，或者发送方自己丢失了数据，导致接收方什么都接受不到，那么，发送方这个时候是不会接收到任何接收方的确定指令的。如果发送方持续等待，就会造成资源的浪费。所以，停止等待协议提出了**超时重传机制**：发送方每发送一次数据的时候，都会开启一个计时器，如果在规定时间内接到接收方的确定，那么就发送数据，同时把计时器重置；如果在规定时间内，未能接收到接收方的确定指令，那么，就重新发送这段数据，同时重置数据，这个就是超时重传机制。  
超时重传需要注意：  
（1）发送方在发送完数据后，必须保留数据的副本，以备超时重传；  
（2）发送方和接收方对数据发送和确认必须进行编号，这样发送方才知道，需要重新发送的是哪段数据；  
（3）超时时间不能设置过短，这样会导致资源浪费，同时不能设置过长，长时间处于等待确认状态也是会耗费大量的网络资源。超时重传时间应该比平均往返时间还要略长一点。  
确认丢失和确认迟到处理：  
在传输过程中，还有两种情况，那就是，接收方确实是接到了发送方的数据，但是在给发送方的确认丢失了，或者迟到了。由于超时重连机制，发送方会继续发送认为丢失的数据。这个时候，接收方接收到这个数据，应该做出以下动作:  
1 丢弃接收到的重复数据，不传输给应用层；  
2 发送确认报文，通知发送方这段数据已经收到，不用继续发送。  
到此，我们已经可以让网络进行可靠的数据传输了，但是停止等待协议会让信道利用率降低数据传输的往返和接收方数据梳处理都需要耗费大量的时间，因此需要停止等待协议进行改进，于是，一种新的停止等待协议就诞生了：流水线传输。流水线传输就是让发送方可以连续传输多个分组，不必等到发送方一个一个确定才发送数据，这样可以使信道上一直有数据在传输  

*2.2 连续ARQ协议*  
ARQ协议的全名是Automatic Repeat reQuest。也就是我们所说的滑动窗口协议。滑动窗口协议的精髓是，发送方维持一个发送窗口，这个窗口可以发送5个分组。发送方每次的发送动作，其实就是把这个发送窗口往前移动。比如发送方把1-5的分组发送到接收方，接收方接收到1后，对1进行确认，那么发送窗口就可以继续迁移到6的分组处，然后继续发送数据。  
为了提高速度，一般接受方不会一条条对分组进行确认，而是累计起来，一次性对数据进行确认。但这个的问题是，不能向发送方反馈已经接收到的所有分组的信息。比如发送方已经发送了1-5的数据分组，但是接收方由于第3的分组丢失，导致接收方只能返回第2分组的确认。发送方无法确认4 5分组是否已经发送成功，只能继续传输3-5的分组。这样也会造成资源的浪费。  
###三 TCP的可靠性传输  
**3.1 TCP发送窗口**  
在前面的连续ARQ协议中，我们知道，在没有收到接收方的确认时，A可以连续把窗口内的数据都发送出去，在未收到确认前，发送方都必须要保留发送数据的副本，以备超时重传。发送窗口具有以下几个特点：  
（1）发送窗口的前沿数据表示不允许发送的数据，后沿数据表示已经发送并且受到确认的数据；  
（2）发送窗口内的部分=已经发送待确定数据+允许发送的数据（可用窗口）。  
（3）发送窗口的位置由前沿和后沿的位置决定，发送窗口后沿的变化有两种，一是不动，而是前移（受到确认） 

**3.2 TCP缓存**  
发送方的应用进程把字节流写入TCP发送缓存中，而接收方的应用进程从TCP的接受缓存中读取字节流。那么，TCP发送缓存中，存放着以下缓存：  
（1）发送方应用程序准备发送的数据；  
（2）发送方已经发送，但是还没有被确认的数据。  
而接收方缓存，存放着以下的数据：  
（1）按序到达的，但是没有被接收方应用程序读取的数据；  
（2）未按序到达的数据。  
如果接收应用程序来不及读取收到的数据，那么接收缓存就会被填满，而接收窗口就会被减少到0，反之，如果应用程序可以及时从接受缓存中接收到数据，那么接收窗口就可以增大，但最大不能超过缓存的大小。同时，我们还应该注意：  
（1）发送窗口不一定和接收窗口一样大，在一般情况下，发送窗口应该比接收窗口要小，甚至在网络不畅的情况下，发送窗口还会自己减小发送窗口的大小；  
（2）TCP对不按序到达的数据，都是先临时存放在接收窗口中，等字节流所缺少的字节到达后，才交付给应用程序；  
（3）TCP要求接收方必须要累积确认的功能，这样可以减少传输开销。接收方不可以过分推迟发送确认，因为这样会导致发送方不必要的重传。一般，推迟时间不能超过0.5s。  
###四 TCP流量控制  
流量控制，指的是让发送方的发送速率不要太快，要让接收方来得及接收。  
**4.1 利用滑动窗口**  
滑动窗口总结来说，就是由接收方决定发送方发送多大的发送窗口rwnd。接收方发送数据格式 = ACK=1,ack=序号（100、200...),rwnd=XXX。  
滑动窗口有一个问题，就是接收方给发送方的确认，在传输过程中，如果丢弃了，那么接收方在等待发送方的发送数据，而发送方一直在等待接收方返回的rwnd非0的通知，这样就会造成死锁的产生。  
TCP为了解决这个问题，设计了持续计时器。在TCP接到对方的零窗口通知后，就启动一个计时器，如果计时器事件到达后，接收方还没有返回rwnd，那么探测器就会发送一个零窗口刺探报文，如果窗口依然是0，那么接到这个报文段后，计时器重置为0；如果窗口不为0，那么死锁的局面就可以被打破。  
###五 TCP的拥塞控制  
所谓拥塞控制，就是防止过多的数据注入网络中，这样可以使网络中的路由器或者链路不导致过载，拥塞控制是全局性的过程，设计所有的主机、路由器以及降低网络传输性能有关的所有因素。  

**5.1 拥塞控制的方法：**  

*1 慢开始和拥塞避免*  
（1）慢开始：有小到大逐渐增大发送窗口，也就是说，有小到大逐渐增加拥塞窗口的数据，每收到一个对新的报文段的确认后，就把拥塞窗口增加一个mss的数量，逐渐增大发送方的拥塞窗口cwnd。  
慢开始算法不可能无限制的增大拥塞窗口的大小，过大的拥塞窗口也会引起网络拥塞，因此还需要设置一个慢开始门限。  
当拥塞窗口<慢开始门限时：使用慢开始算法；  
当拥塞窗口>慢开始门限时：使用拥塞避免算法；
当拥塞窗口=慢开始门限时：两个算法都可以。  
（2）拥塞避免算法：让拥塞窗口缓慢的增大，每次把拥塞窗口+1而不是翻倍，这样可以使拥塞窗口呈线性规律缓慢的增长。  
无论是慢开始算法还是拥塞避免算法，只要发送方判断网络出现拥塞，那么就要把慢开始门限限制为出现拥塞时发送窗口的一半。然后把拥塞窗口重新赋值为1，执行慢开始算法，这样做的目的是快速的减少网络中的分组数，使发生拥塞的路由器有足够的时间把队列中的分组处理完毕。  

*2 快重传和快恢复*  
（1）快重传算法要求接收方每收到一个失序的报文段后立即发出重复确认而不要等待自己发送数据时才进行捎带确认。快重传算法规定，发送方一旦重复收到三次某个报文段的确认，就需要立即重传对方尚未接收到的报文段，而不必继续等待重传计时器到期。  
（2）快恢复算法一般配合快重传算法一起使用，当发送方连续收到三个重复确认的时候，就执行算法减小算法，把慢开始门限减半，防止网络拥塞。接着，把拥塞窗口的值设置为慢开始门限减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢的线性增大。  
###六 TCP的运输连接管理  
**6.1 TCP连接的建立（三次握手）**  
过程：  
发送方发送：SYN=1，seq=x给接收方  
接收方接到数据，返回：SYN=1，ack=x+1，seq=y，ACK=1；  
发送方接到数据，返回：SYN=1，ack=y+1,seq=x+1;   
经过这三个步奏，我们就可以确认已经建立了连接了。那么，问题来了，为什么TCP需要多一次的连接确定呢？这个是主要为了防止已经失效的连接请求报文又突然传送给了B，因此产生错误。主要表现为：A向B发出了连接请求，但是这个时候，这个请求被滞留在了网络中，这个时候由于超时重传机制，A又重新发送了一个连接请求，B重新给与确定，这个时候AB连接成功，A发送完数据后，断开了请求。这个时候，网络中A的第一次请求又到了B出，B又重新给A确定连接的应答，但是A已经发送完了数据，因此不会去理会这个B的应答，而B确认为A需要传输数据，这样B的资源就被浪费了。  

**6.2 TCP连接的断开（四次挥手）**   
过程：  
A发送FIN=1，seq=u给B；（FIN-WAIT-1）  
B接收到数据，返回：ACK=1，seq=v，ack=u+1；(FIN-WAIT-2)  
这个阶段，表面A不再向B发送数据，但是B如果又数据放回个A的话，那么A还是必须接收到的  
B发送 FIN=1，ACK=1，seq=w,ack=u+1;  
A发送 ACK=1,ack=w+1,seq=u+1;  
这个时候，B接收到A的应答，那么服务端就会断开这次的TCP请求，而接收端并不会马上断开连接，而是要等待2个msl后，才会真正断开tcp连接，这是为什么呢？  
（1）A发送给B的应答报文可能会丢失。这个时候，B会发生超时重传，因此，A总会在两个msl内接收到B的请求断开报文；  
（2）防止已失效的连接请求报文出现在本连接中。  
我们可以注意到，B断开TCP连接的时间，要比A快~~  
###七 总结  
至此，TCP的介绍已经结束，篇幅很长，还是需要好好研究呀~~

  

 


  

